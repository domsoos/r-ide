{
	// Place your r-ide workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }

	"def listener": {
		//"scope": "python",
		"prefix": "def listener",
		"body": [
		  "#!/usr/bin/env python",
		  "import rospy",
		  "from std_msgs.msg import String",
		  "",
		  "def callback(data):",
		  "    rospy.loginfo(rospy.get_caller_id() + \"I heard %s\", data.data)",
		  "",
		  "def listener():",
		  "",
		  "    # In ROS, nodes are uniquely named. If two nodes with the same",
		  "    # name are launched, the previous one is kicked off. The",
		  "    # anonymous=True flag means that rospy will choose a unique",
		  "    # name for our 'listener' node so that multiple listeners can",
		  "    # run simultaneously.",
		  "    rospy.init_node('listener', anonymous=True)",
		  "",
		  "    rospy.Subscriber(\"chatter\", String, callback)",
		  "",
		  "    # spin() simply keeps python from exiting until this node is stopped",
		  "    rospy.spin()",
		  "",
		  "if __name__ == '__main__':",
		  "listener()",
		  "",
		  "# Refernece: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29"
		],
		"description": "def listener",
		"isFileTemplate": true
	  },

	  "subscriber node example": {
		//"scope": "C++",
		"prefix": "subscriber node example",
		"body": [
		  "#include \"ros/ros.h\"",
		  "#include \"std_msgs/String.h\"",
		  "",
		  "/**",
		  " * This tutorial demonstrates simple receipt of messages over the ROS system.",
		  " */",
		  "void chatterCallback(const std_msgs::String::ConstPtr& msg)",
		  "{",
		  "  ROS_INFO(\"I heard: [%s]\", msg->data.c_str());",
		  "}",
		  "",
		  "int main(int argc, char **argv)",
		  "{",
		  "  /**",
		  "   * The ros::init() function needs to see argc and argv so that it can perform",
		  "   * any ROS arguments and name remapping that were provided at the command line.",
		  "   * For programmatic remappings you can use a different version of init() which takes",
		  "   * remappings directly, but for most command-line programs, passing argc and argv is",
		  "   * the easiest way to do it.  The third argument to init() is the name of the node.",
		  "   *",
		  "   * You must call one of the versions of ros::init() before using any other",
		  "   * part of the ROS system.",
		  "   */",
		  "  ros::init(argc, argv, \"listener\");",
		  "",
		  "  /**",
		  "   * NodeHandle is the main access point to communications with the ROS system.",
		  "   * The first NodeHandle constructed will fully initialize this node, and the last",
		  "   * NodeHandle destructed will close down the node.",
		  "   */",
		  "  ros::NodeHandle n;",
		  "",
		  "  /**",
		  "   * The subscribe() call is how you tell ROS that you want to receive messages",
		  "   * on a given topic.  This invokes a call to the ROS",
		  "   * master node, which keeps a registry of who is publishing and who",
		  "   * is subscribing.  Messages are passed to a callback function, here",
		  "   * called chatterCallback.  subscribe() returns a Subscriber object that you",
		  "   * must hold on to until you want to unsubscribe.  When all copies of the Subscriber",
		  "   * object go out of scope, this callback will automatically be unsubscribed from",
		  "   * this topic.",
		  "   *",
		  "   * The second parameter to the subscribe() function is the size of the message",
		  "   * queue.  If messages are arriving faster than they are being processed, this",
		  "   * is the number of messages that will be buffered up before beginning to throw",
		  "   * away the oldest ones.",
		  "   */",
		  "  ros::Subscriber sub = n.subscribe(\"chatter\", 1000, chatterCallback);",
		  "",
		  "  /**",
		  "   * ros::spin() will enter a loop, pumping callbacks.  With this version, all",
		  "   * callbacks will be called from within this thread (the main one).  ros::spin()",
		  "   * will exit when Ctrl-C is pressed, or the node is shutdown by the master.",
		  "   */",
		  "  ros::spin();",
		  "",
		  "  return 0;",
		  "}",
		  "/**",
		  " * Reference: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29",
		  " */"
		],
		"description": "subscriber node example",
		"isFileTemplate": true
	  },

	  "def talker": {
		//"scope": "python", 
		"prefix": "def talker",
		"body": [
		  "# This line makes sure your script executes as Python     ",
		  "#!/usr/bin/env python",
		  "",
		  "# license removed for brevity",
		  "",
		  "# You need to import rospy to create a ROS node     ",
		  "# The std_msgs.msg import is so the user can reuse the string for publishing     ",
		  "import rospy",
		  "from std_msgs.msg import String",
		  "",
		  "def talker():",
		  "",
		  "# pub = rospy.Publisher() is declaring that your node is publishing to the chatter topic   ",
		  "# using the message type String. The queue_size limits the amount    ",
		  "# of queued messages if any subscriber is not receiving them fast enough    ",
		  "    pub = rospy.Publisher('chatter', String, queue_size=10)",
		  "",
		  "# rospy.init_node tells rospy the name of your node    ",
		  "# Until rospy has this information it cannot communicate wiht the ROS Master   ",
		  "# anonymous = True makes sure your node has a unique name by adding random numbers to the end   ",
		  "    rospy.init_node('talker', anonymous=True)",
		  "",
		  "# Rate offers a method of sleep() that has convenient way for looping a desired rate   ",
		  "# the argument of 10 ensures it should loop 10 times per second    ",
		  "    rate = rospy.Rate(10) # 10hz",
		  "",
		  "# while loop to check if program should exit   ",
		  "    while not rospy.is_shutdown():",
		  "        hello_str = \"hello world %s\" % rospy.get_time()",
		  "        rospy.loginfo(hello_str)",
		  "        pub.publish(hello_str)",
		  "        rate.sleep()",
		  "",
		  "if __name__ == '__main__':",
		  "    try:",
		  "        talker()",
		  "    except rospy.ROSInterruptException:",
		  "        pass",
		  "",
		  "# Reference: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28python%29"
		],
		"description": "def talker",
		"isFileTemplate": true,
		
	  },

	  "publisher node example": {
		//"scope": "C++",
		"prefix": "publisher node example",
		"body": [
		  "#include \"ros/ros.h\"",
		  "#include \"std_msgs/String.h\"",
		  "",
		  "#include <sstream>",
		  "",
		  "/**",
		  " * This tutorial demonstrates simple sending of messages over the ROS system.",
		  " */",
		  "int main(int argc, char **argv)",
		  "{",
		  "  /**",
		  "   * The ros::init() function needs to see argc and argv so that it can perform",
		  "   * any ROS arguments and name remapping that were provided at the command line.",
		  "   * For programmatic remappings you can use a different version of init() which takes",
		  "   * remappings directly, but for most command-line programs, passing argc and argv is",
		  "   * the easiest way to do it.  The third argument to init() is the name of the node.",
		  "   *",
		  "   * You must call one of the versions of ros::init() before using any other",
		  "   * part of the ROS system.",
		  "   */",
		  "  ros::init(argc, argv, \"talker\");",
		  "",
		  "  /**",
		  "   * NodeHandle is the main access point to communications with the ROS system.",
		  "   * The first NodeHandle constructed will fully initialize this node, and the last",
		  "   * NodeHandle destructed will close down the node.",
		  "   */",
		  "  ros::NodeHandle n;",
		  "",
		  "  /**",
		  "   * The advertise() function is how you tell ROS that you want to",
		  "   * publish on a given topic name. This invokes a call to the ROS",
		  "   * master node, which keeps a registry of who is publishing and who",
		  "   * is subscribing. After this advertise() call is made, the master",
		  "   * node will notify anyone who is trying to subscribe to this topic name,",
		  "   * and they will in turn negotiate a peer-to-peer connection with this",
		  "   * node.  advertise() returns a Publisher object which allows you to",
		  "   * publish messages on that topic through a call to publish().  Once",
		  "   * all copies of the returned Publisher object are destroyed, the topic",
		  "   * will be automatically unadvertised.",
		  "   *",
		  "   * The second parameter to advertise() is the size of the message queue",
		  "   * used for publishing messages.  If messages are published more quickly",
		  "   * than we can send them, the number here specifies how many messages to",
		  "   * buffer up before throwing some away.",
		  "   */",
		  "  ros::Publisher chatter_pub = n.advertise<std_msgs::String>(\"chatter\", 1000);",
		  "",
		  "  ros::Rate loop_rate(10);",
		  "",
		  "  /**",
		  "   * A count of how many messages we have sent. This is used to create",
		  "   * a unique string for each message.",
		  "   */",
		  "  int count = 0;",
		  "  while (ros::ok())",
		  "  {",
		  "    /**",
		  "     * This is a message object. You stuff it with data, and then publish it.",
		  "     */",
		  "    std_msgs::String msg;",
		  "",
		  "    std::stringstream ss;",
		  "    ss << \"hello world \" << count;",
		  "    msg.data = ss.str();",
		  "",
		  "    ROS_INFO(\"%s\", msg.data.c_str());",
		  "",
		  "    /**",
		  "     * The publish() function is how you send messages. The parameter",
		  "     * is the message object. The type of this object must agree with the type",
		  "     * given as a template parameter to the advertise<>() call, as was done",
		  "     * in the constructor above.",
		  "     */",
		  "    chatter_pub.publish(msg);",
		  "",
		  "    ros::spinOnce();",
		  "",
		  "    loop_rate.sleep();",
		  "    ++count;",
		  "  }",
		  "",
		  "",
		  "  return 0;",
		  "}",
		  "",
		  "/**",
		  " * Reference: http://wiki.ros.org/ROS/Tutorials/WritingPublisherSubscriber%28c%2B%2B%29",
		  " */"
		],
		"description": "publisher node example",
		"isFileTemplate": true
	  },

	  "srv example": {
		//"scope": "python",
		"prefix": "srv example",
		"body": [
		  "#!/usr/bin/env python",
		  "",
		  "from __future__ import print_function",
		  "",
		  "from beginner_tutorials.srv import AddTwoInts,AddTwoIntsResponse",
		  "import rospy",
		  "",
		  "def handle_add_two_ints(req):",
		  "    print(\"Returning [%s + %s = %s]\"%(req.a, req.b, (req.a + req.b)))",
		  "    return AddTwoIntsResponse(req.a + req.b)",
		  "",
		  "def add_two_ints_server():",
		  "    rospy.init_node('add_two_ints_server')",
		  "    s = rospy.Service('add_two_ints', AddTwoInts, handle_add_two_ints)",
		  "    print(\"Ready to add two ints.\")",
		  "    rospy.spin()",
		  "",
		  "if __name__ == \"__main__\":",
		  "    add_two_ints_server()",
		  "# Reference: http://wiki.ros.org/ROS/Tutorials/WritingServiceClient%28python%29"
		],
		"description": "srv example",
		"isFileTemplate": true
	  },

	  "msg example": {
		//"scope": "python",
		"prefix": "msg example",
		"body": [
		  "int32 X=123",
		  "int32 Y=-123",
		  "string FOO=foo",
		  "string EXAMPLE=\"#comments\" are ignored, and leading and trailing whitespace removed",
		  "",
		  "reference: http://wiki.ros.org/msg"
		],
		"description": "msg example",
		"isFileTemplate": true
	  },

	  "urdf example": {
		//"scope": "C++"
		"prefix": "urdf example",
		"body": [
		  "<robot name=\"test_robot\">",
		  "  <link name=\"link1\" />",
		  "  <link name=\"link2\" />",
		  "  <link name=\"link3\" />",
		  "  <link name=\"link4\" />",
		  "",
		  "  <joint name=\"joint1\" type=\"continuous\">",
		  "    <parent link=\"link1\"/>",
		  "    <child link=\"link2\"/>",
		  "  </joint>",
		  "",
		  "  <joint name=\"joint2\" type=\"continuous\">",
		  "    <parent link=\"link1\"/>",
		  "    <child link=\"link3\"/>",
		  "  </joint>",
		  "",
		  "  <joint name=\"joint3\" type=\"continuous\">",
		  "    <parent link=\"link3\"/>",
		  "    <child link=\"link4\"/>",
		  "  </joint>",
		  "</robot>",
		  "",
		  "/**",
		  " * Reference: http://wiki.ros.org/urdf/Tutorials/Create%20your%20own%20urdf%20file",
		  " */"
		],
		"description": "urdf example",
		"isFileTemplate": true
	  }

	

}