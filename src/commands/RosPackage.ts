import * as vscode from "vscode";
import { relative } from "path";

// TODO: Add setting to turn off auto updates to package and cmake files
const disclaimer = `# WARNING: This section was auto-generated by R-IDE
# R-IDE may make changes inside these tags without warning and delete and edits made by the user
# To turn off R-IDE maintaining this file: `;

export class RosPackage {
    constructor(directory: vscode.Uri) {
        RosPackage.packages.set(directory.fsPath, this);
        this.rootDirectory = directory;
        this.msgWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.msg');
        this.srvWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.srv');

        this.msgWatcher.onDidCreate(async uri => {
            this.addMsg(uri);
        });

        this.msgWatcher.onDidDelete(async uri => {
            this.msg.delete(uri.fsPath);
            this.updateCmake('msg');
        });

        this.srvWatcher.onDidCreate(async uri => {
            this.addSrv(uri);
        });

        this.srvWatcher.onDidDelete(async uri => {
            this.srv.delete(uri.fsPath);
            this.updateCmake('srv');
        });

        const config = vscode.workspace.getConfiguration('r-ide');
        config.update('RosPackage.packages', RosPackage.packages);

        return this;
    }

    static packages = new Map<string, RosPackage>();
    

    msg = new Set<string>();
    srv = new Set<string>();
    actions = new Set<string>();
    nodes = new Map();

    // File System Watchers
    msgWatcher: vscode.FileSystemWatcher;
    srvWatcher: vscode.FileSystemWatcher;


    rootDirectory;
    cMakeVersion = '';
    projectName = '';

    /**
     * Adds a message file to the package
     * @param path The path to the message file
     */
    public addMsg(...path: vscode.Uri[]) {
        for (let p of path) {
            this.msg.add(p.fsPath);
        }
        this.updateCmake('msg');
    }

    /**
     * Adds a service file to the package  
     * @param path The path to the service file
     */
    public addSrv(...path: vscode.Uri[]) {
        for (let p of path) {
            this.srv.add(p.fsPath);
        }
        this.updateCmake('srv');
    }

    /**
     * Adds an action file to the package
     * @param path The path to the action file
     */
    public addAction(...path: vscode.Uri[]) {
        for (let p of path) {
            this.actions.add(p.fsPath);
        }
        this.updateCmake('action');
    }

    /**
     * Adds a node to the package
     * @param node A JSON object that describes the relevant pieces of the node
     */
    public addNode(node: {
        name: string, 
        path: vscode.Uri
        imports?: [],
        isPublisher?: boolean,
        isSubscriber?: boolean
        
        // TODO: Add other stuff as needed
    }) {
        this.nodes.set(node.path, node);
    }

    public async updateCmake(partition: string) {
        vscode.workspace.openTextDocument(vscode.Uri.joinPath(this.rootDirectory, './CMakeLists.txt')).then(document => {
            let text = document.getText();

            vscode.window.showTextDocument(document, 1, true).then(editor => {
                let files: string[] = [];
                let marker: string;
                let longMarker: string;
                let directory: vscode.Uri;
                

                // TODO: Assumes that the files are located in ./$partition 
                switch (partition) {
                    case ('msg'): {
                        marker = 'msg';
                        longMarker = 'message';
                        directory = vscode.Uri.joinPath(this.rootDirectory, './msg');
                        this.msg.forEach(msg => {
                            files.push(relative(directory.fsPath, msg));
                        });
                        break;
                    }

                    case ('srv'): {
                        marker = 'srv';
                        longMarker = 'service';
                        directory = vscode.Uri.joinPath(this.rootDirectory, './srv');
                        this.srv.forEach(srv => {
                            files.push(relative(directory.fsPath, srv));
                        });
                        break;
                    }

                    default: {
                        vscode.window.showErrorMessage(`Could not parse what was being updated. Recieved ${partition}`);
                        return;
                    }
                }

                const tags = generateRideTags(marker);
                let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                let match = text.match(regexp);

                if (match?.index) {
                    let replaceText: string;

                    if (files.length === 0) {
                        replaceText = `${tags[0]}\n` +
                        `${disclaimer}\n\n` +
                        `${tags[1]}\n`;
                    } else {
                        replaceText = `${tags[0]}\n` +
                        `${disclaimer}\n\n` +
                        `add_${longMarker}_files(\n` +
                        `    DIRECTORY ${marker}\n` +
                        `    FILES\n` +
                        `    ${files.join('\n    ')}\n` +
                        ')\n\n' +
                        `${tags[1]}\n`;
                    }

                    let start = document.positionAt(match.index);
                    let end = document.positionAt(match.index + match[0].length);

                    editor.selection = new vscode.Selection(start, end);

                    editor.edit(editBuilder => {
                        editBuilder.replace(editor.selection, replaceText);
                    });
                } else {
                    vscode.window.showErrorMessage(`Could not find R-IDE tags for ${marker}`);
                }
            });
        });
        
    }

    private generateFindPackage() {
        return '';
    }

    private setupPythonSupport() {
        return '';
    }

    private generateMsg() {
        const tags = generateRideTags('msg'); 
        if (this.msg.size === 0) {
            return `${tags[0]}` +
            `${disclaimer}\n` + 
            '# No messages to add\n' +
            `${tags[1]}\n`;
        }
        // TODO: Assumes that messages are placed in the msg directory, this might not be the case
        let directory = './msg';
        let files = [];

        for (let msg of this.msg) {
            files.push(relative(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, msg));
        }

        return  `${tags[0]}` +
        `${disclaimer}\n\n` + 
        'add_message_files(\n' +
        '    DIRECTORY msg\n' + 
        '    FILES\n' + 
        `    ${files.join('\n    ')}\n` + 
        ')\n\n' +
        `${tags[1]}\n`;
    }

    private generateSrv() {
        const tags = generateRideTags('srv'); 
        if (this.srv.size === 0) {
            return `${tags[0]}` +
            `${disclaimer}\n` + 
            '# No services to add\n' +
            `${tags[1]}\n`;
        }
        // TODO: Assumes that services are placed in the srv directory, this might not be the case
        let directory = './srv';
        let files = [];

        for (let srv of this.srv) {
            files.push(relative(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, srv));
        }
        return  `${tags[0]}` +
        `${disclaimer}\n\n` + 
        'add_service_files(\n' +
        '    DIRECTORY msg\n' + 
        '    FILES\n' + 
        `    ${files.join('\n    ')}\n` + 
        ')\n\n' +
        `${tags[1]}\n`;
    }

    private generateAction() {
        return `
        # START ACTION
        ${disclaimer}

        add_action_files(
            DIRECTORY <directory_1>
            FILES <action_files_1>
        )

        # END ACTION`;
    }

    private generateMessagesFunc() {
        return '';
    }

    private generateCatkinPackage() {
        return '';
    }

    private addLibrariesAndExecutables() {
        return '';
    }

    private addTests() {
        return '';
    }

    private installRules() {
        return '';
    }

    /**
     * Generates the text for the CMakeLists.txt file
     * @returns Returns the text of the CMakeLists.txt
     */
    public generateCMakeLists() {
        return '# http://wiki.ros.org/catkin/CMakeLists.txt \n' +
        '\n' +
        `cmake_minimnum_required(${this.cMakeVersion})\n` +
        `project(${this.projectName})\n` +
        '\n\n' +
        '# Find Packages\n' + 
        `${this.generateFindPackage()}\n` +
        '\n\n' +
        '# Enable Python Module Support\n' +
        `${this.setupPythonSupport()}\n` +
        '\n\n' +
        '# Add Msg, Srv, and Action files\n' +
        `${this.generateMsg()}\n` +
        '\n' +
        `${this.generateSrv()}\n` +
        '\n' +
        `${this.generateAction()}\n` +
        '\n\n' +
        '# Generate messages\n' +
        `${this.generateMessagesFunc()}\n` +
        '\n\n' +
        '# Specify Package Build Info\n' +
        `${this.generateCatkinPackage()}\n` +
        '\n\n' +
        '# Add libraries and executables\n' +
        `${this.addLibrariesAndExecutables()}\n` +
        '\n\n' +
        '# Tests to build\n' +
        `${this.addTests()}\n` +
        '\n\n' +
        '# Install rules\n' +
        `${this.installRules()}\n`;
    }

    /**
     * Generates the text for the package.xml file
     * @returns Returns the text of the package.xml
     */
    public generatePackageXml() {
        return ``;
    }

}

/**
 * Creates and builds a new ROS package and creates a template directory
 * @returns A new ROS package
 */
export async function createRosPackage() {
    let name = await vscode.window.showInputBox({
        title: "Package Name"
    });

    if (!name) {
        return;
    }

    name = name.replace(/\s/g, '_').toLowerCase();

    let directory: any = await vscode.window.showOpenDialog({
        title: "Where should the directory be placed?",
        canSelectFiles: false,
        canSelectFolders: true,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    if (!directory) {
        return;
    }

    // Create the directory
    directory = vscode.Uri.joinPath(directory[0], name);
    vscode.workspace.fs.createDirectory(directory);

    // Build the package in memory
    let package_ = new RosPackage(directory);
    package_.projectName = name;

    // Create recommended directories
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './src'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './include'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './config'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './msg'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './srv'));

    // Create package and CMake files
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'CMakeLists.txt'), Buffer.from(package_.generateCMakeLists()));
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'package.xml'), Buffer.from(package_.generatePackageXml()));

    return package_;

}

/**
 * Prompts the user for a pacakge
 * @returns A selected package
 */
export async function selectPackage(): Promise<RosPackage | undefined> {
    let selectedPackage = await vscode.window.showOpenDialog({
        title: "Select a Package Directory",
        canSelectFolders: true,
        canSelectFiles: false,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    // Check user selected a package
    if (!selectedPackage) {
        return;
    }
    
    // Package does not yet exist, prompt for creation
    if (!RosPackage.packages.has(selectedPackage[0].fsPath)) {
        await vscode.window.showInformationMessage(`No package is registered at ${selectedPackage[0]}\nWould you like to create one?`, "Yes", "No").then((answer => {
            if (answer === 'Yes') {
                // TODO: For some reason TS thinks selectedPackage can be undefined here
                if (selectedPackage) {
                    return new RosPackage(selectedPackage[0]);
                }
            } else {
                return;
            }
        }));
    }
    return RosPackage.packages.get(selectedPackage[0].fsPath);
}

/**
 * Connects a message to a package, allows the user to be prompted for the package and messages
 * @param package The selected package
 * @param messages The selected messages
 * @returns None
 */
export async function addMsgToPackage(package_?: RosPackage, messages?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!messages) {
        let selectedMessage = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['msg']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedMessage) {
            return;
        }

        messages = selectedMessage;
    }

    package_.addMsg(...messages);
}

/**
 * Connects a service to a package, allows the user to be prompted for the package and services
 * @param package The selected package
 * @param services The selected services
 * @returns None
 */
export async function addSrvToPackage(package_?: RosPackage, services?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!services) {
        let selectedService = await vscode.window.showOpenDialog({
            title: "Select Service files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['srv']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedService) {
            return;
        }

        services = selectedService;
    }

    package_.addSrv(...services);
}

export function addActionToPackage(package_: RosPackage, action: vscode.Uri) {
    package_.addAction(action);
}

export function addNodeToPackage(package_: RosPackage, node: vscode.Uri) {

}

/**
 * Registers a pacakge for the workspace
 * @param directory The package directory
 * @returns None
 */
export async function registerPackage(directory? : vscode.Uri) {
    if (!directory) {
        let selectedDirectory = await vscode.window.showOpenDialog({
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false
        });

        // User cancelled
        if (!selectedDirectory) {
            return;
        }

        directory = selectedDirectory[0];
    }

    new RosPackage(directory);
}

export async function deregisterPacakge(directory : vscode.Uri) {
    RosPackage.packages.delete(directory.fsPath);
    const config = vscode.workspace.getConfiguration('r-ide');
    config.update('RosPackage.packages', RosPackage.packages);
}

export async function loadPackages() {
    const config = vscode.workspace.getConfiguration('r-ide');
    let p = config.get<Map<string, RosPackage>>('RosPackage.packages');

    //console.log(p);

    if (p) {
        for (let entry of p) {
            RosPackage.packages.set(entry[0], entry[1]);
        }
    }
    
}

/**
 * Generates tags to start and end a RIDE auto-generate section
 * @param marker Marks what is being managed between these tags
 * @returns An array of size 2 with the start and end tags
 */
function generateRideTags(marker: string) {
    return [`# !RIDE START ${marker.toUpperCase()}`, `# !RIDE END ${marker.toUpperCase()}`];
}
