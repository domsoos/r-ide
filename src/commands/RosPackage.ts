import * as vscode from "vscode";
import { relative } from "path";

// TODO: Add setting to turn off auto updates to package and cmake files
const disclaimer = `# WARNING: This section was auto-generated by R-IDE
# R-IDE may make changes inside these tags without warning and delete and edits made by the user
# To turn off R-IDE maintaining this file: `;

export class RosPackage {
    constructor(directory: vscode.Uri) {
        RosPackage.packages.set(directory.fsPath, this);
        this.rootDirectory = directory;
        this.msgWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.msg');
        // this.srvWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.srv');

        this.msgWatcher.onDidCreate(async uri => {
            this.addMsg(uri);
        });

        this.msgWatcher.onDidDelete(async uri => {
            this.msg.delete(uri.fsPath);
            this.updateCmake('msg');
        });

        const config = vscode.workspace.getConfiguration('r-ide');
        config.update('RosPackage.packages', RosPackage.packages);

        return this;
    }

    static packages = new Map<string, RosPackage>();
    

    msg = new Set<string>();
    srv = new Set<string>();
    actions = new Set<string>();
    nodes = new Map();

    // File System Watchers
    msgWatcher: vscode.FileSystemWatcher;
    // srvWatcher: vscode.FileSystemWatcher;


    rootDirectory;
    cMakeVersion = '';
    projectName = '';

    /**
     * Adds a message file to the package
     * @param path The path to the message file
     */
    public addMsg(...path: vscode.Uri[]) {
        for (let p of path) {
            this.msg.add(p.fsPath);
        }
        this.updateCmake('msg');
    }

    /**
     * Adds a service file to the package  
     * @param path The path to the service file
     */
    public addSrv(...path: vscode.Uri[]) {
        for (let p of path) {
            this.srv.add(p.fsPath);
        }
        this.updateCmake('srv');
    }

    /**
     * Adds an action file to the package
     * @param path The path to the action file
     */
    public addAction(...path: vscode.Uri[]) {
        for (let p of path) {
            this.actions.add(p.fsPath);
        }
        this.updateCmake('action');
    }

    /**
     * Adds a node to the package
     * @param node A JSON object that describes the relevant pieces of the node
     */
    public addNode(node: {
        name: string, 
        path: vscode.Uri
        imports?: [],
        isPublisher?: boolean,
        isSubscriber?: boolean
        
        // TODO: Add other stuff as needed
    }) {
        this.nodes.set(node.path, node);
    }

    public async updateCmake(partition: string) {
        vscode.workspace.openTextDocument(vscode.Uri.joinPath(this.rootDirectory, './CMakeLists.txt')).then(document => {
            let text = document.getText();

            vscode.window.showTextDocument(document, 1, true).then(editor => {
                switch (partition) {
                        case ('msg'): {
                            // TODO: The message files may not all be in package_root/msg
                            let directory = vscode.Uri.joinPath(this.rootDirectory, './msg');
                            let files: string[] = [];

                            this.msg.forEach(msg => {
                                console.log(msg);
                                files.push(relative(directory.fsPath, msg));
                            });

                            let match = text.match(/# START MSG.*?# END MSG/s);
                            let replaceText: string;
                            
                            if (this.msg.size !== 0) {
                                replaceText =  '# START MSG\n' +
                                `${disclaimer}\n\n` + 
                                'add_message_files(\n' +
                                '    DIRECTORY msg\n' + 
                                '    FILES\n' + 
                                `    ${files.join('\n    ')}\n` + 
                                ')\n\n' +
                                '# END MSG';
                            } else {
                                replaceText =  '# START MSG\n' +
                                `${disclaimer}\n\n` + 
                                '# END MSG';
                            }

                            if (match?.index) {
                                
                                let start = document.positionAt(match.index);
                                let end = document.positionAt(match.index + match[0].length);

                                editor.selection = new vscode.Selection(start, end);

                                editor.edit(editBuilder => {
                                    editBuilder.replace(editor.selection, replaceText);
                                });

                            } else {
                                vscode.window.showErrorMessage("Could not find R-IDE tags for msg");
                            }

                            break;
                        }
                    }
            });
        });
        
    }

    private generateFindPackage() {
        return '';
    }

    private setupPythonSupport() {
        return '';
    }

    private generateMsg() {
        if (this.msg.size === 0) {
            return '# START MSG\n' +
            `${disclaimer}\n` + 
            '# END MSG';
        }
        // TODO: Assumes that messages are placed in the msg directory, this might not be the case
        let directory = './msg';
        let files = [];

        for (let msg of this.msg) {
            files.push(relative(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, msg));
        }

        return '# START MSG\n' +
        `${disclaimer}\n\n` + 
        'add_message_files(\n' +
        '    DIRECTORY msg\n' + 
        '    FILES\n' + 
        `    ${files.join('\n    ')}\n` + 
        ')\n\n' +
        '# END MSG';
    }

    private generateSrv() {
        return `
        # START SRV
        ${disclaimer}

        add_service_files(
            DIRECTORY <directory_1>
            FILES <service_files_1>
        )

        # END SRV`;
    }

    private generateAction() {
        return `
        # START ACTION
        ${disclaimer}

        add_action_files(
            DIRECTORY <directory_1>
            FILES <action_files_1>
        )

        # END ACTION`;
    }

    private generateMessagesFunc() {
        return '';
    }

    private generateCatkinPackage() {
        return '';
    }

    private addLibrariesAndExecutables() {
        return '';
    }

    private addTests() {
        return '';
    }

    private installRules() {
        return '';
    }

    /**
     * Generates the text for the CMakeLists.txt file
     * @returns Returns the text of the CMakeLists.txt
     */
    public generateCMakeLists() {
        return '# http://wiki.ros.org/catkin/CMakeLists.txt\n' +
        '\n' +
        `cmake_minimnum_required(${this.cMakeVersion})\n` +
        `project(${this.projectName})\n` +
        '\n\n' +
        '# Find Packages\n' + 
        `${this.generateFindPackage()}\n` +
        '\n\n' +
        '# Enable Python Module Support\n' +
        `${this.setupPythonSupport()}\n` +
        '\n\n' +
        '# Add Msg, Srv, and Action files\n' +
        `${this.generateMsg()}\n` +
        '\n' +
        `${this.generateSrv()}\n` +
        '\n' +
        `${this.generateAction()}\n` +
        '\n\n' +
        '# Generate messages\n' +
        `${this.generateMessagesFunc()}\n` +
        '\n\n' +
        '# Specify Package Build Info\n' +
        `${this.generateCatkinPackage()}\n` +
        '\n\n' +
        '# Add libraries and executables\n' +
        `${this.addLibrariesAndExecutables()}\n` +
        '\n\n' +
        '# Tests to build\n' +
        `${this.addTests()}\n` +
        '\n\n' +
        '# Install rules\n' +
        `${this.installRules()}\n`;
    }

    /**
     * Generates the text for the package.xml file
     * @returns Returns the text of the package.xml
     */
    public generatePackageXml() {
        return ``;
    }

}

/**
 * Creates and builds a new ROS package and creates a template directory
 * @returns A new ROS package
 */
export async function createRosPackage() {
    let name = await vscode.window.showInputBox({
        title: "Package Name"
    });

    if (!name) {
        return;
    }

    name = name.replace(/\s/g, '_').toLowerCase();

    let directory: any = await vscode.window.showOpenDialog({
        title: "Where should the directory be placed?",
        canSelectFiles: false,
        canSelectFolders: true,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    if (!directory) {
        return;
    }

    // Create the directory
    directory = vscode.Uri.joinPath(directory[0], name);
    vscode.workspace.fs.createDirectory(directory);

    // Build the package in memory
    let package_ = new RosPackage(directory);
    package_.projectName = name;

    // Create recommended directories
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './src'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './include'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './config'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './msg'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './srv'));

    // Create package and CMake files
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'CMakeLists.txt'), Buffer.from(package_.generateCMakeLists()));
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'package.xml'), Buffer.from(package_.generatePackageXml()));

    return package_;

}

/**
 * Prompts the user for a pacakge
 * @returns A selected package
 */
export async function selectPackage(): Promise<RosPackage | undefined> {
    let selectedPackage = await vscode.window.showOpenDialog({
        title: "Select a Package Directory",
        canSelectFolders: true,
        canSelectFiles: false,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    // Check user selected a package
    if (!selectedPackage) {
        return;
    }
    
    // Package does not yet exist, prompt for creation
    if (!RosPackage.packages.has(selectedPackage[0].fsPath)) {
        await vscode.window.showInformationMessage(`No package is registered at ${selectedPackage[0]}\nWould you like to create one?`, "Yes", "No").then((answer => {
            if (answer === 'Yes') {
                // TODO: For some reason TS thinks selectedPackage can be undefined here
                if (selectedPackage) {
                    return new RosPackage(selectedPackage[0]);
                }
            } else {
                return;
            }
        }));
    }
    return RosPackage.packages.get(selectedPackage[0].fsPath);
}

/**
 * Connects a message to a package, allows the user to be prompted for the package and messages
 * @param package The selected package
 * @param messages The selected messages
 * @returns None
 */
export async function addMsgToPackage(package_?: RosPackage, messages?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!messages) {
        let selectedMessage = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['msg']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedMessage) {
            return;
        }

        messages = selectedMessage;
    }

    package_.addMsg(...messages);
}

/**
 * Connects a service to a package, allows the user to be prompted for the package and services
 * @param package The selected package
 * @param services The selected services
 * @returns None
 */
export async function addSrvToPackage(package_?: RosPackage, services?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!services) {
        let selectedService = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['srv']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedService) {
            return;
        }

        services = selectedService;
    }

    package_.addSrv(...services);
}

export function addActionToPackage(package_: RosPackage, action: vscode.Uri) {
    package_.addAction(action);
}

export function addNodeToPackage(package_: RosPackage, node: vscode.Uri) {

}

/**
 * Registers a pacakge for the workspace
 * @param directory The package directory
 * @returns None
 */
export async function registerPackage(directory? : vscode.Uri) {
    if (!directory) {
        let selectedDirectory = await vscode.window.showOpenDialog({
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false
        });

        // User cancelled
        if (!selectedDirectory) {
            return;
        }

        directory = selectedDirectory[0];
    }

    new RosPackage(directory);
}

export async function deregisterPacakge(directory : vscode.Uri) {
    RosPackage.packages.delete(directory.fsPath);
    const config = vscode.workspace.getConfiguration('r-ide');
    config.update('RosPackage.packages', RosPackage.packages);
}

export async function loadPackages() {
    const config = vscode.workspace.getConfiguration('r-ide');
    let p = config.get<Map<string, RosPackage>>('RosPackage.packages');

    console.log(p);

    if (p) {
        for (let entry of p) {
            RosPackage.packages.set(entry[0], entry[1]);
        }
    }
    
}