import { TextEncoder } from "util";
import * as vscode from "vscode";

// TODO: Add setting to turn off auto updates to package and cmake files
const disclaimer = `# WARNING: This section was auto-generated by R-IDE
# R-IDE may make changes inside these tags without warning and delete and edits made by the user
# To turn off R-IDE maintaining this file: `;

export class RosProject {
    constructor(directory: vscode.Uri) {
        RosProject.projects.set(directory.fsPath, this);
        this.rootDirectory = directory.fsPath;

        return this;
    }

    static projects = new Map();
    

    msg: vscode.Uri[] = [];
    srv: vscode.Uri[] = [];
    actions: vscode.Uri[] = [];
    nodes: {}[] = [];

    rootDirectory = '';
    cMakeVersion = '';
    projectName = '';

    /**
     * Adds a message file to the project
     * @param path The path to the message file
     */
    public addMsg(path: vscode.Uri) {
        this.msg.push(path);
    }

    /**
     * Adds a service file to the project
     * @param path The path to the service file
     */
    public addSrv(path: vscode.Uri) {
        this.srv.push(path);
    }

    /**
     * Adds an action file to the project
     * @param path The path to the action file
     */
    public addAction(path: vscode.Uri) {
        this.actions.push(path);
    }

    /**
     * Adds a node to the project
     * @param node A JSON object that describes the relevant pieces of the node
     */
    public addNode(node: {
        name: string, 
        path: vscode.Uri
        imports?: [],
        isPublisher?: boolean,
        isSubscriber?: boolean
        
        // TODO: Add other stuff as needed
    }) {
        this.nodes.push(node);
    }

    private generateFindPackage() {
        return '';
    }

    private setupPythonSupport() {
        return '';
    }

    private generateMsg() {
        return `# START MSG
        ${disclaimer}
        
        add_message_files(
            DIRECTORY <directory_1>
            FILES <message_files_1>
        )

        # END MSG`;
    }

    private generateSrv() {
        return `# START SRV
        ${disclaimer}
        
        add_service_files(
            DIRECTORY <directory_1>
            FILES <service_files_1>
        )

        # END SRV`;
    }

    private generateAction() {
        return `# START ACTION
        ${disclaimer}
        
        add_action_files(
            DIRECTORY <directory_1>
            FILES <action_files_1>
        )

        # END ACTION`;
    }

    private generateMessagesFunc() {
        return '';
    }

    private generateCatkinPackage() {
        return '';
    }

    private addLibrariesAndExecutables() {
        return '';
    }

    private addTests() {
        return '';
    }

    private installRules() {
        return '';
    }

    /**
     * Generates the text for the CMakeLists.txt file
     * @returns Returns the text of the CMakeLists.txt
     */
    public generateCMakeLists() {
        return ` # http://wiki.ros.org/catkin/CMakeLists.txt
        
        cmake_minimnum_required(${this.cMakeVersion})
        project(${this.projectName})
        
        # Find Packages
        ${this.generateFindPackage()}

        # Enable Python Module Support
        ${this.setupPythonSupport()}

        # Add Msg, Srv, and Action files
        ${this.generateMsg()}
        ${this.generateSrv()}
        ${this.generateAction()}

        # Generate messages
        ${this.generateMessagesFunc()}

        # Specify Package Build Info
        ${this.generateCatkinPackage()}

        # Add libraries and executables
        ${this.addLibrariesAndExecutables()}

        # Tests to build
        ${this.addTests()}

        # Install rules
        ${this.installRules()}

        `;
    }

    /**
     * Generates the text for the package.xml file
     * @returns Returns the text of the package.xml
     */
    public generatePackageXml() {
        return ``;
    }

}

/**
 * Creates and builds a new ROS package and creates a template directory
 * @returns A new ROS package
 */
export async function createRosProject() {
    let name = await vscode.window.showInputBox({
        title: "Project Name"
    });

    if (!name) {
        return;
    }

    name = name.replace(' ', '_').toLowerCase();

    let directory: any = await vscode.window.showOpenDialog({
        title: "Where should the directory be placed?",
        canSelectFiles: false,
        canSelectFolders: true,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    if (!directory) {
        return;
    }

    directory = vscode.Uri.joinPath(directory[0], name);

    vscode.workspace.fs.createDirectory(directory);
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './src'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './include'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './config'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './msg'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './srv'));

    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'CMakeLists.txt'), Buffer.from(""));
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'package.xml'), Buffer.from(""));

    let project = new RosProject(directory);
    project.projectName = name;

    return project;

}

/**
 * Prompts the user for a project
 * @returns A selected project
 */
export async function selectProject(): Promise<RosProject | undefined> {
    let selectedProject = await vscode.window.showOpenDialog({
        title: "Select a Project Directory",
        canSelectFolders: true,
        canSelectFiles: false,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    // Check user selected a project
    if (!selectedProject) {
        return;
    }
    
    // Project does not yet exist, prompt for creation
    if (!RosProject.projects.has(selectedProject[0].fsPath)) {
        await vscode.window.showInformationMessage(`No project is registered at ${selectedProject[0]}\nWould you like to create one?`, "Yes", "No").then((answer => {
            if (answer === 'Yes') {
                // TODO: For some reason TS thinks selectedProject can be undefined here
                if (selectedProject) {
                    return new RosProject(selectedProject[0]);
                }
            } else {
                return;
            }
        }));
    }
    return RosProject.projects.get(selectedProject[0].fsPath);
}

/**
 * Connects a message to a project, allows the user to be prompted for the project and messages
 * @param project The selected project
 * @param messages The selected messages
 * @returns None
 */
export async function addMsgToProject(project?: RosProject, messages?: vscode.Uri[]) {
    if (!project) {
        project = await selectProject();

        // User cancelled
        if (!project) {
            return;
        }
    }

    if (!messages) {
        let selectedMessage = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['msg']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: vscode.Uri.file(project.rootDirectory)
        });

        // Check user selected messages
        if (!selectedMessage) {
            return;
        }

        messages = selectedMessage;
    }

    for (let msg of messages) {
        console.log(msg.fsPath);
        project.addMsg(msg);
    }
    
}

/**
 * Connects a service to a project, allows the user to be prompted for the project and services
 * @param project The selected project
 * @param services The selected services
 * @returns None
 */
export async function addSrvToProject(project?: RosProject, services?: vscode.Uri[]) {
    if (!project) {
        project = await selectProject();

        // User cancelled
        if (!project) {
            return;
        }
    }

    if (!services) {
        let selectedService = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['srv']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: vscode.Uri.file(project.rootDirectory)
        });

        // Check user selected messages
        if (!selectedService) {
            return;
        }

        services = selectedService;
    }

    for (let srv of services) {
        console.log(srv.fsPath);
        project.addMsg(srv);
    }
}

export function addActionToProject(project: RosProject, action: vscode.Uri) {
    project.addAction(action);
}

export function addNodeToProject(project: RosProject, node: vscode.Uri) {
    // vscode.workspace.openTextDocument(node).then(document => {
    //     const text = document.getText();

    //     switch (document.languageId) {
    //         case ('python'): {
    //             project.addNode(
    //                 {
    //                     'name': document.fileName,
    //                     'path': node,
    //                     'imports': text.match(/(import|from) ((\s),?)*/g),
    //                     // 'isPublisher': 
    //                     // 'isSubscriber': 
    //                 }
    //             );
    //             break;
    //         }

    //         case ('cpp'): {
    //             break;
    //         }

    //         default: {
    //             vscode.window.showErrorMessage(`Could not read node: ${document.uri}. ${document.languageId}`);
    //         }
    //     }
    // });
}

/**
 * Registers a pacakge for the workspace
 * @param directory The project directory
 * @returns None
 */
export async function registerProject(directory? : vscode.Uri) {
    if (!directory) {
        let selectedDirectory = await vscode.window.showOpenDialog({
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false
        });

        // User cancelled
        if (!selectedDirectory) {
            return;
        }

        directory = selectedDirectory[0];
    }

    new RosProject(directory);
}