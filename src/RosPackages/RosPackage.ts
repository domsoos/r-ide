import * as vscode from "vscode";
import { relative } from "path";
import * as cp from "child_process";

// TODO: Add setting to turn off auto updates to package and cmake files
const disclaimer = `# WARNING: This section was auto-generated by R-IDE
# R-IDE may make changes inside these tags without warning and delete and edits made by the user
# To turn off R-IDE maintaining this file: `;

export class RosPackage {
    constructor(directory: vscode.Uri) {
        RosPackage.packages.set(directory.fsPath, this);
        this.rootDirectory = directory;

        // File system watchers
        this.msgWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.msg');
        this.srvWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.srv');
        this.srcWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/src/**/*.{py,cpp}');

        this.msgWatcher.onDidCreate(async uri => {
            this.addMsg(uri);
        });

        this.msgWatcher.onDidDelete(async uri => {
            this.msg.delete(uri.fsPath);
            this.updateCmake('msg');
        });

        this.srvWatcher.onDidCreate(async uri => {
            this.addSrv(uri);
        });

        this.srvWatcher.onDidDelete(async uri => {
            this.srv.delete(uri.fsPath);
            this.updateCmake('srv');
        });

        this.srcWatcher.onDidCreate(async uri => {
            this.addSrcFile(uri);
        });

        this.srcWatcher.onDidChange(async uri => {
            let didChange = false;
            for (let required of await readFileForRosPackages(uri)) {
                if (!this.requiredPackages.has(required)) {
                    this.requiredPackages.set(required, new Set([uri.fsPath]));
                    didChange = true;
                } else if (!this.requiredPackages.get(required)?.has(uri.fsPath)) {
                    this.requiredPackages.get(required)?.add(uri.fsPath);
                    didChange = true;
                }
            }

            if (didChange) {
                this.updateCmake('src');
            }
        });

        this.srcWatcher.onDidDelete(async uri => {
            this.srcFiles.delete(uri.fsPath);
            this.updateCmake('src');
        });

        const config = vscode.workspace.getConfiguration('r-ide');
        config.update('RosPackage.packages', RosPackage.packages);

        return this;
    }

    static packages = new Map<string, RosPackage>();
    // Get all exisiting packages
    static existingPackages: Set<string>;

    msg = new Set<string>();
    srv = new Set<string>();
    actions = new Set<string>();
    srcFiles = new Set<string>();

    requiredPackages = new Map<string, Set<string>>();

    // File System Watchers
    msgWatcher: vscode.FileSystemWatcher;
    srvWatcher: vscode.FileSystemWatcher;
    srcWatcher: vscode.FileSystemWatcher;

    rootDirectory;
    cMakeVersion = '';
    projectName = '';

    /**
     * Adds a message file to the package
     * @param path The path to the message file
     */
    public addMsg(...path: vscode.Uri[]) {
        for (let p of path) {
            this.msg.add(p.fsPath);
        }
        this.updateCmake('msg');
    }

    /**
     * Adds a service file to the package  
     * @param path The path to the service file
     */
    public addSrv(...path: vscode.Uri[]) {
        for (let p of path) {
            this.srv.add(p.fsPath);
        }
        this.updateCmake('srv');
    }

    /**
     * Adds an action file to the package
     * @param path The path to the action file
     */
    public addAction(...path: vscode.Uri[]) {
        for (let p of path) {
            this.actions.add(p.fsPath);
        }
        this.updateCmake('action');
    }

    /**
     * Updates the srcFiles array and then updates the cmake
     * @param path The path(s) to the new src files
     */
    public async addSrcFile(...path: vscode.Uri[]) {
        // Check if we have new required packages
        let didChange = false;

        for (let p of path) {
            this.srcFiles.add(p.fsPath);
            for (let required of await readFileForRosPackages(p)) {
                if (!this.requiredPackages.has(required)) {
                    this.requiredPackages.set(required, new Set([p.fsPath]));
                    didChange = true;
                } else if (!this.requiredPackages.get(required)?.has(p.fsPath)) {
                    this.requiredPackages.get(required)?.add(p.fsPath);
                    didChange = true;
                }
            }
        }

        if (didChange) {
            this.updateCmake('src');
        }
        
    }

    public async updateCmake(partition: string) {
        let cMake = vscode.Uri.joinPath(this.rootDirectory, './CMakeLists.txt');            
        // TODO: Assumes that the files are located in ./$partition 
        switch (partition) {
            case ('msg'): {
                let replaceText = this.generateMsg();
                let tags = generateRideTags('msg');
                let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                replaceTextInDocument(cMake, regexp, replaceText);
                break;
            }

            case ('srv'): {
                let replaceText = this.generateSrv();
                let tags = generateRideTags('srv');
                let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                replaceTextInDocument(cMake, regexp, replaceText);
                break;
            }

            case ('action'): {
                let replaceText = this.generateAction();
                let tags = generateRideTags('action');
                let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                replaceTextInDocument(cMake, regexp, replaceText);
                break;
            }

            case ('src'): {
                let replaceText = this.generateFindPackage();
                let tags = generateRideTags('find_package');
                let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                replaceTextInDocument(cMake, regexp, replaceText);
                break;
            }

            default: {
                vscode.window.showErrorMessage(`Could not parse what was being updated. Recieved ${partition}`);
                return;
            }
        }
    }

    private generateFindPackage() {
        let findPackages = `find_packages(catkin REQUIRED ${this.requiredPackages.size > 0 ? 'COMPONENTS' : '\n# No Packages to add'} ${[...this.requiredPackages.keys()].join('\n    ')}`;

        const tags = generateRideTags('find_package');

        
        return `${tags[0]} \n${findPackages} \n${tags[1]}`;
    }

    private setupPythonSupport() {
        return '';
    }

    private generateMsg() {
        const tags = generateRideTags('msg'); 
        if (this.msg.size === 0) {
            return `${tags[0]}\n` +
            `${disclaimer}\n\n` + 
            '# No messages to add\n' +
            `${tags[1]}\n`;
        }
        // TODO: Assumes that messages are placed in the msg directory, this might not be the case
        let directory = './msg';
        let files = [];

        for (let msg of this.msg) {
            files.push(relative(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, msg));
        }

        return  `${tags[0]}\n` +
        `${disclaimer}\n\n` + 
        'add_message_files(\n' +
        '    DIRECTORY msg\n' + 
        '    FILES\n' + 
        `    ${files.join('\n    ')}\n` + 
        ')\n\n' +
        `${tags[1]}\n`;
    }

    private generateSrv() {
        const tags = generateRideTags('srv'); 
        if (this.srv.size === 0) {
            return `${tags[0]}\n` +
            `${disclaimer}\n` + 
            '# No services to add\n' +
            `${tags[1]}\n`;
        }
        // TODO: Assumes that services are placed in the srv directory, this might not be the case
        let directory = './srv';
        let files = [];

        for (let srv of this.srv) {
            files.push(relative(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, srv));
        }
        return `${tags[0]}\n` +
        `${disclaimer}\n\n` + 
        'add_service_files(\n' +
        '    DIRECTORY srv\n' + 
        '    FILES\n' + 
        `    ${files.join('\n    ')}\n` + 
        ')\n\n' +
        `${tags[1]}\n`;
    }

    private generateAction() {
        return `
        # START ACTION
        ${disclaimer}

        add_action_files(
            DIRECTORY <directory_1>
            FILES <action_files_1>
        )

        # END ACTION`;
    }

    private generateMessagesFunc() {
        return '';
    }

    private generateCatkinPackage() {
        return '';
    }

    private addLibrariesAndExecutables() {
        return '';
    }

    private addTests() {
        return '';
    }

    private installRules() {
        return '';
    }

    /**
     * Generates the text for the CMakeLists.txt file
     * @returns Returns the text of the CMakeLists.txt
     */
    public generateCMakeLists() {
        return '# http://wiki.ros.org/catkin/CMakeLists.txt \n' +
        '\n' +
        `cmake_minimnum_required(${this.cMakeVersion})\n` +
        `project(${this.projectName})\n` +
        '\n\n' +
        '# Find Packages\n' + 
        `${this.generateFindPackage()}\n\n)` +
        '\n\n' +
        '# Enable Python Module Support\n' +
        `${this.setupPythonSupport()}\n` +
        '\n\n' +
        '# Add Msg, Srv, and Action files\n' +
        `${this.generateMsg()}\n` +
        '\n' +
        `${this.generateSrv()}\n` +
        '\n' +
        `${this.generateAction()}\n` +
        '\n\n' +
        '# Generate messages\n' +
        `${this.generateMessagesFunc()}\n` +
        '\n\n' +
        '# Specify Package Build Info\n' +
        `${this.generateCatkinPackage()}\n` +
        '\n\n' +
        '# Add libraries and executables\n' +
        `${this.addLibrariesAndExecutables()}\n` +
        '\n\n' +
        '# Tests to build\n' +
        `${this.addTests()}\n` +
        '\n\n' +
        '# Install rules\n' +
        `${this.installRules()}\n`;
    }

    /**
     * Generates the text for the package.xml file
     * @returns Returns the text of the package.xml
     */
    public generatePackageXml() {
        return ``;
    }

}

/**
 * Creates and builds a new ROS package and creates a template directory
 * @returns A new ROS package
 */
export async function createRosPackage() {
    let name = await vscode.window.showInputBox({
        title: "Package Name"
    });

    if (!name) {
        return;
    }

    if (!name.match(/^[a-zA-Z][a-zA-Z0-9_]*$/)) {
        let newName = name.replace(/\s/g, '_').toLowerCase();
        await vscode.window.showInformationMessage(`${name} will be changed to ${newName}, is that OK?`, 'Yes', 'No').then(answer => {
            if (answer === "Yes") {
                name = newName;
            } else {
                return;
            }
        });
    }
   

    let directory: any = await vscode.window.showOpenDialog({
        title: "Where should the directory be placed?",
        canSelectFiles: false,
        canSelectFolders: true,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    if (!directory) {
        return;
    }

    // Create the directory
    directory = vscode.Uri.joinPath(directory[0], name);
    vscode.workspace.fs.createDirectory(directory);

    // Build the package in memory
    let package_ = new RosPackage(directory);
    package_.projectName = name;

    // Create recommended directories
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './src'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './include'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './config'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './msg'));
    vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './srv'));

    // Create package and CMake files
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'CMakeLists.txt'), Buffer.from(package_.generateCMakeLists()));
    vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'package.xml'), Buffer.from(package_.generatePackageXml()));

    return package_;

}

/**
 * Prompts the user for a pacakge
 * @returns A selected package
 */
export async function selectPackage(): Promise<RosPackage | undefined> {
    let selectedPackage = await vscode.window.showOpenDialog({
        title: "Select a Package Directory",
        canSelectFolders: true,
        canSelectFiles: false,
        canSelectMany: false,
        defaultUri: vscode.Uri.file(vscode.workspace.workspaceFolders?.map(folder => folder.uri.path).toString() + '/')
    });

    // Check user selected a package
    if (!selectedPackage) {
        return;
    }
    
    // Package does not yet exist, prompt for creation
    if (!RosPackage.packages.has(selectedPackage[0].fsPath)) {
        await vscode.window.showInformationMessage(`No package is registered at ${selectedPackage[0]}\nWould you like to create one?`, "Yes", "No").then((answer => {
            if (answer === 'Yes') {
                // TODO: For some reason TS thinks selectedPackage can be undefined here
                if (selectedPackage) {
                    return new RosPackage(selectedPackage[0]);
                }
            } else {
                return;
            }
        }));
    }
    return RosPackage.packages.get(selectedPackage[0].fsPath);
}

/**
 * Connects a message to a package, allows the user to be prompted for the package and messages
 * @param package The selected package
 * @param messages The selected messages
 * @returns None
 */
export async function addMsgToPackage(package_?: RosPackage, messages?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!messages) {
        let selectedMessage = await vscode.window.showOpenDialog({
            title: "Select Message files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['msg']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedMessage) {
            return;
        }

        messages = selectedMessage;
    }

    package_.addMsg(...messages);
}

/**
 * Connects a service to a package, allows the user to be prompted for the package and services
 * @param package The selected package
 * @param services The selected services
 * @returns None
 */
export async function addSrvToPackage(package_?: RosPackage, services?: vscode.Uri[]) {
    if (!package_) {
        package_ = await selectPackage();

        // User cancelled
        if (!package_) {
            return;
        }
    }

    if (!services) {
        let selectedService = await vscode.window.showOpenDialog({
            title: "Select Service files",
            // eslint-disable-next-line @typescript-eslint/naming-convention
            filters: {"Text Files": ['srv']},
            canSelectFolders: false,
            canSelectFiles: true,
            canSelectMany: true,
            defaultUri: package_.rootDirectory
        });

        // Check user selected messages
        if (!selectedService) {
            return;
        }

        services = selectedService;
    }

    package_.addSrv(...services);
}

export function addActionToPackage(package_: RosPackage, action: vscode.Uri) {
    package_.addAction(action);
}

export function addNodeToPackage(package_: RosPackage, node: vscode.Uri) {

}

/**
 * Registers a pacakge for the workspace
 * @param directory The package directory
 * @returns None
 */
export async function registerPackage(directory? : vscode.Uri) {
    if (!directory) {
        let selectedDirectory = await vscode.window.showOpenDialog({
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false
        });

        // User cancelled
        if (!selectedDirectory) {
            return;
        }

        directory = selectedDirectory[0];
    }

    new RosPackage(directory);
}

export async function deregisterPacakge(directory : vscode.Uri) {
    RosPackage.packages.delete(directory.fsPath);
    const config = vscode.workspace.getConfiguration('r-ide');
    config.update('RosPackage.packages', RosPackage.packages);
}

export async function loadPackages() {
    const config = vscode.workspace.getConfiguration('r-ide');
    let p = config.get<Map<string, RosPackage>>('RosPackage.packages');

    if (p) {
        for (let entry of p) {
            RosPackage.packages.set(entry[0], entry[1]);
        }
    }
    
}

/**
 * Generates tags to start and end a RIDE auto-generate section
 * @param marker Marks what is being managed between these tags
 * @returns An array of size 2 with the start and end tags
 */
function generateRideTags(marker: string) {
    return [`# !RIDE START ${marker.toUpperCase()}`, `# !RIDE END ${marker.toUpperCase()}`];
}

/**
 * Updates the RosProject existing packages based on the results of `rospack list-names`
 */
export function updateExistingPackages() {
    // This command might be limited to some later ros distros
    RosPackage.existingPackages = new Set(cp.execSync(`rospack list-names`).toString().split('\n'));
}

/**
 * Read a file and identify any possible rospackages
 * @param path The uri path to the file
 * @returns A list of required ROS packages for this file
 */
async function readFileForRosPackages(path: vscode.Uri) {
    let otherPackages: Set<string> = new Set();
    await vscode.workspace.openTextDocument(path).then(document => {
        const text = document.getText();

        // Python
        if (/import/.test(text)) {
            const regex = /import\s+(\w+)|from\s+(\w+(\.\w+)*)\s+import\s+(\w+(,\s*\w+)*)/g;
            let matches = text.matchAll(regex);


            for (let match of matches) {
                let packageName = match[1] || match[2];
                if (RosPackage.existingPackages.has(packageName)) {
                    otherPackages.add(packageName);
                }
            }

        // CPP
        } else if (/include/.test(text)) {
            const regex = /#include\s+["<](\S+)[">]/gm;
            let matches = text.matchAll(regex);


            for (let match of matches) {
                let packageName = match[1];
                if (RosPackage.existingPackages.has(packageName)) {
                    otherPackages.add(packageName);
                }
            }
        }
    });

    return otherPackages;
}

function replaceTextInDocument(uri: vscode.Uri, regexp: RegExp, replaceText: string) {
    let start: vscode.Position;
    let end: vscode.Position;

    vscode.workspace.openTextDocument(uri).then(document => {
        let match = document.getText().match(regexp);

        if (match?.index) {

            start = document.positionAt(match.index);
            end = document.positionAt(match.index + match[0].length);

            const edit = new vscode.WorkspaceEdit();
            const editRange = new vscode.Range(start, end);
            const makeEdit = new vscode.TextEdit(editRange, replaceText);

            edit.set(uri, [makeEdit]);
            vscode.workspace.applyEdit(edit);
        } else {
            throw new Error("Could not find R-IDE tags");
        }
    });

    vscode.window.showInformationMessage(`Updated ${uri.fsPath}`, `Open Document`).then(answer => {
        if (answer === 'Open Document') {
            vscode.window.showTextDocument(uri, {selection: new vscode.Range(start, start.translate({characterDelta: replaceText.length}))});
        }
    });
}