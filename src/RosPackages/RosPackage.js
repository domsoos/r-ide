"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateExistingPackages = exports.loadPackages = exports.deregisterPacakge = exports.registerPackage = exports.addNodeToPackage = exports.addActionToPackage = exports.addSrvToPackage = exports.addMsgToPackage = exports.selectPackage = exports.createRosPackage = exports.RosPackage = void 0;
const vscode = __importStar(require("vscode"));
const path_1 = require("path");
// TODO: Add setting to turn off auto updates to package and cmake files
const disclaimer = `# WARNING: This section was auto-generated by R-IDE
# R-IDE may make changes inside these tags without warning and delete and edits made by the user
# To turn off R-IDE maintaining this file: `;
class RosPackage {
    constructor(directory) {
        this.msg = new Set();
        this.srv = new Set();
        this.actions = new Set();
        this.srcFiles = new Set();
        this.requiredPackages = new Map();
        this.cMakeVersion = '';
        this.projectName = '';
        RosPackage.packages.set(directory.fsPath, this);
        this.rootDirectory = directory;
        // File system watchers
        this.msgWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.msg');
        this.srvWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/**/*.srv');
        this.srcWatcher = vscode.workspace.createFileSystemWatcher(this.rootDirectory.fsPath + '/src/**/*.{py,cpp}');
        this.msgWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () {
            this.addMsg(uri);
        }));
        this.msgWatcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () {
            this.msg.delete(uri.fsPath);
            this.updateCmake('msg');
        }));
        this.srvWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () {
            this.addSrv(uri);
        }));
        this.srvWatcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () {
            this.srv.delete(uri.fsPath);
            this.updateCmake('srv');
        }));
        this.srcWatcher.onDidCreate((uri) => __awaiter(this, void 0, void 0, function* () {
            this.addSrcFile(uri);
        }));
        this.srcWatcher.onDidChange((uri) => __awaiter(this, void 0, void 0, function* () {
            var _a, _b;
            let didChange = false;
            for (let required of yield readFileForRosPackages(uri)) {
                if (!this.requiredPackages.has(required)) {
                    this.requiredPackages.set(required, new Set([uri.fsPath]));
                    didChange = true;
                }
                else if (!((_a = this.requiredPackages.get(required)) === null || _a === void 0 ? void 0 : _a.has(uri.fsPath))) {
                    (_b = this.requiredPackages.get(required)) === null || _b === void 0 ? void 0 : _b.add(uri.fsPath);
                    didChange = true;
                }
            }
            if (didChange) {
                this.updateCmake('src');
            }
        }));
        this.srcWatcher.onDidDelete((uri) => __awaiter(this, void 0, void 0, function* () {
            this.srcFiles.delete(uri.fsPath);
            this.updateCmake('src');
        }));
        const config = vscode.workspace.getConfiguration('r-ide');
        config.update('RosPackage.packages', RosPackage.packages);
        return this;
    }
    /**
     * Adds a message file to the package
     * @param path The path to the message file
     */
    addMsg(...path) {
        for (let p of path) {
            this.msg.add(p.fsPath);
        }
        this.updateCmake('msg');
    }
    /**
     * Adds a service file to the package
     * @param path The path to the service file
     */
    addSrv(...path) {
        for (let p of path) {
            this.srv.add(p.fsPath);
        }
        this.updateCmake('srv');
    }
    /**
     * Adds an action file to the package
     * @param path The path to the action file
     */
    addAction(...path) {
        for (let p of path) {
            this.actions.add(p.fsPath);
        }
        this.updateCmake('action');
    }
    /**
     * Updates the srcFiles array and then updates the cmake
     * @param path The path(s) to the new src files
     */
    addSrcFile(...path) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            // Check if we have new required packages
            let didChange = false;
            for (let p of path) {
                this.srcFiles.add(p.fsPath);
                for (let required of yield readFileForRosPackages(p)) {
                    if (!this.requiredPackages.has(required)) {
                        this.requiredPackages.set(required, new Set([p.fsPath]));
                        didChange = true;
                    }
                    else if (!((_a = this.requiredPackages.get(required)) === null || _a === void 0 ? void 0 : _a.has(p.fsPath))) {
                        (_b = this.requiredPackages.get(required)) === null || _b === void 0 ? void 0 : _b.add(p.fsPath);
                        didChange = true;
                    }
                }
            }
            if (didChange) {
                this.updateCmake('src');
            }
        });
    }
    updateCmake(partition) {
        return __awaiter(this, void 0, void 0, function* () {
            let cMake = vscode.Uri.joinPath(this.rootDirectory, './CMakeLists.txt');
            // TODO: Assumes that the files are located in ./$partition 
            switch (partition) {
                case ('msg'): {
                    let replaceText = this.generateMsg();
                    let tags = generateRideTags('msg');
                    let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                    replaceTextInDocument(cMake, regexp, replaceText);
                    break;
                }
                case ('srv'): {
                    let replaceText = this.generateSrv();
                    let tags = generateRideTags('srv');
                    let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                    replaceTextInDocument(cMake, regexp, replaceText);
                    break;
                }
                case ('action'): {
                    let replaceText = this.generateAction();
                    let tags = generateRideTags('action');
                    let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                    replaceTextInDocument(cMake, regexp, replaceText);
                    break;
                }
                case ('src'): {
                    let replaceText = this.generateFindPackage();
                    let tags = generateRideTags('find_package');
                    let regexp = new RegExp(`${tags[0]}.*?${tags[1]}`, 's');
                    replaceTextInDocument(cMake, regexp, replaceText);
                    break;
                }
                default: {
                    vscode.window.showErrorMessage(`Could not parse what was being updated. Recieved ${partition}`);
                    return;
                }
            }
        });
    }
    generateFindPackage() {
        let findPackages = `find_packages(catkin REQUIRED ${this.requiredPackages.size > 0 ? 'COMPONENTS' : '\n# No Packages to add'} ${[...this.requiredPackages.keys()].join('\n    ')}`;
        const tags = generateRideTags('find_package');
        return `${tags[0]} \n${findPackages} \n${tags[1]}`;
    }
    setupPythonSupport() {
        return '';
    }
    generateMsg() {
        const tags = generateRideTags('msg');
        if (this.msg.size === 0) {
            return `${tags[0]}\n` +
                `${disclaimer}\n\n` +
                '# No messages to add\n' +
                `${tags[1]}\n`;
        }
        // TODO: Assumes that messages are placed in the msg directory, this might not be the case
        let directory = './msg';
        let files = [];
        for (let msg of this.msg) {
            files.push((0, path_1.relative)(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, msg));
        }
        return `${tags[0]}\n` +
            `${disclaimer}\n\n` +
            'add_message_files(\n' +
            '    DIRECTORY msg\n' +
            '    FILES\n' +
            `    ${files.join('\n    ')}\n` +
            ')\n\n' +
            `${tags[1]}\n`;
    }
    generateSrv() {
        const tags = generateRideTags('srv');
        if (this.srv.size === 0) {
            return `${tags[0]}\n` +
                `${disclaimer}\n` +
                '# No services to add\n' +
                `${tags[1]}\n`;
        }
        // TODO: Assumes that services are placed in the srv directory, this might not be the case
        let directory = './srv';
        let files = [];
        for (let srv of this.srv) {
            files.push((0, path_1.relative)(vscode.Uri.joinPath(this.rootDirectory, directory).fsPath, srv));
        }
        return `${tags[0]}\n` +
            `${disclaimer}\n\n` +
            'add_service_files(\n' +
            '    DIRECTORY srv\n' +
            '    FILES\n' +
            `    ${files.join('\n    ')}\n` +
            ')\n\n' +
            `${tags[1]}\n`;
    }
    generateAction() {
        return `
        # START ACTION
        ${disclaimer}

        add_action_files(
            DIRECTORY <directory_1>
            FILES <action_files_1>
        )

        # END ACTION`;
    }
    generateMessagesFunc() {
        return '';
    }
    generateCatkinPackage() {
        return '';
    }
    addLibrariesAndExecutables() {
        return '';
    }
    addTests() {
        return '';
    }
    installRules() {
        return '';
    }
    /**
     * Generates the text for the CMakeLists.txt file
     * @returns Returns the text of the CMakeLists.txt
     */
    generateCMakeLists() {
        return '# http://wiki.ros.org/catkin/CMakeLists.txt \n' +
            '\n' +
            `cmake_minimnum_required(${this.cMakeVersion})\n` +
            `project(${this.projectName})\n` +
            '\n\n' +
            '# Find Packages\n' +
            `${this.generateFindPackage()}\n\n)` +
            '\n\n' +
            '# Enable Python Module Support\n' +
            `${this.setupPythonSupport()}\n` +
            '\n\n' +
            '# Add Msg, Srv, and Action files\n' +
            `${this.generateMsg()}\n` +
            '\n' +
            `${this.generateSrv()}\n` +
            '\n' +
            `${this.generateAction()}\n` +
            '\n\n' +
            '# Generate messages\n' +
            `${this.generateMessagesFunc()}\n` +
            '\n\n' +
            '# Specify Package Build Info\n' +
            `${this.generateCatkinPackage()}\n` +
            '\n\n' +
            '# Add libraries and executables\n' +
            `${this.addLibrariesAndExecutables()}\n` +
            '\n\n' +
            '# Tests to build\n' +
            `${this.addTests()}\n` +
            '\n\n' +
            '# Install rules\n' +
            `${this.installRules()}\n`;
    }
    /**
     * Generates the text for the package.xml file
     * @returns Returns the text of the package.xml
     */
    generatePackageXml() {
        return ``;
    }
}
exports.RosPackage = RosPackage;
RosPackage.packages = new Map();
/**
 * Creates and builds a new ROS package and creates a template directory
 * @returns A new ROS package
 */
function createRosPackage() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let name = yield vscode.window.showInputBox({
            title: "Package Name"
        });
        if (!name) {
            return;
        }
        if (!name.match(/^[a-zA-Z][a-zA-Z0-9_]*$/)) {
            let newName = name.replace(/\s/g, '_').toLowerCase();
            yield vscode.window.showInformationMessage(`${name} will be changed to ${newName}, is that OK?`, 'Yes', 'No').then(answer => {
                if (answer === "Yes") {
                    name = newName;
                }
                else {
                    return;
                }
            });
        }
        let directory = yield vscode.window.showOpenDialog({
            title: "Where should the directory be placed?",
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false,
            defaultUri: vscode.Uri.file(((_a = vscode.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.map(folder => folder.uri.path).toString()) + '/')
        });
        if (!directory) {
            return;
        }
        // Create the directory
        directory = vscode.Uri.joinPath(directory[0], name);
        vscode.workspace.fs.createDirectory(directory);
        // Build the package in memory
        let package_ = new RosPackage(directory);
        package_.projectName = name;
        // Create recommended directories
        vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './src'));
        vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './include'));
        vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './config'));
        vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './msg'));
        vscode.workspace.fs.createDirectory(vscode.Uri.joinPath(directory, './srv'));
        // Create package and CMake files
        vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'CMakeLists.txt'), Buffer.from(package_.generateCMakeLists()));
        vscode.workspace.fs.writeFile(vscode.Uri.joinPath(directory, 'package.xml'), Buffer.from(package_.generatePackageXml()));
        return package_;
    });
}
exports.createRosPackage = createRosPackage;
/**
 * Prompts the user for a pacakge
 * @returns A selected package
 */
function selectPackage() {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
        let selectedPackage = yield vscode.window.showOpenDialog({
            title: "Select a Package Directory",
            canSelectFolders: true,
            canSelectFiles: false,
            canSelectMany: false,
            defaultUri: vscode.Uri.file(((_a = vscode.workspace.workspaceFolders) === null || _a === void 0 ? void 0 : _a.map(folder => folder.uri.path).toString()) + '/')
        });
        // Check user selected a package
        if (!selectedPackage) {
            return;
        }
        // Package does not yet exist, prompt for creation
        if (!RosPackage.packages.has(selectedPackage[0].fsPath)) {
            yield vscode.window.showInformationMessage(`No package is registered at ${selectedPackage[0]}\nWould you like to create one?`, "Yes", "No").then((answer => {
                if (answer === 'Yes') {
                    // TODO: For some reason TS thinks selectedPackage can be undefined here
                    if (selectedPackage) {
                        return new RosPackage(selectedPackage[0]);
                    }
                }
                else {
                    return;
                }
            }));
        }
        return RosPackage.packages.get(selectedPackage[0].fsPath);
    });
}
exports.selectPackage = selectPackage;
/**
 * Connects a message to a package, allows the user to be prompted for the package and messages
 * @param package The selected package
 * @param messages The selected messages
 * @returns None
 */
function addMsgToPackage(package_, messages) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!package_) {
            package_ = yield selectPackage();
            // User cancelled
            if (!package_) {
                return;
            }
        }
        if (!messages) {
            let selectedMessage = yield vscode.window.showOpenDialog({
                title: "Select Message files",
                // eslint-disable-next-line @typescript-eslint/naming-convention
                filters: { "Text Files": ['msg'] },
                canSelectFolders: false,
                canSelectFiles: true,
                canSelectMany: true,
                defaultUri: package_.rootDirectory
            });
            // Check user selected messages
            if (!selectedMessage) {
                return;
            }
            messages = selectedMessage;
        }
        package_.addMsg(...messages);
    });
}
exports.addMsgToPackage = addMsgToPackage;
/**
 * Connects a service to a package, allows the user to be prompted for the package and services
 * @param package The selected package
 * @param services The selected services
 * @returns None
 */
function addSrvToPackage(package_, services) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!package_) {
            package_ = yield selectPackage();
            // User cancelled
            if (!package_) {
                return;
            }
        }
        if (!services) {
            let selectedService = yield vscode.window.showOpenDialog({
                title: "Select Service files",
                // eslint-disable-next-line @typescript-eslint/naming-convention
                filters: { "Text Files": ['srv'] },
                canSelectFolders: false,
                canSelectFiles: true,
                canSelectMany: true,
                defaultUri: package_.rootDirectory
            });
            // Check user selected messages
            if (!selectedService) {
                return;
            }
            services = selectedService;
        }
        package_.addSrv(...services);
    });
}
exports.addSrvToPackage = addSrvToPackage;
function addActionToPackage(package_, action) {
    package_.addAction(action);
}
exports.addActionToPackage = addActionToPackage;
function addNodeToPackage(package_, node) {
}
exports.addNodeToPackage = addNodeToPackage;
/**
 * Registers a pacakge for the workspace
 * @param directory The package directory
 * @returns None
 */
function registerPackage(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!directory) {
            let selectedDirectory = yield vscode.window.showOpenDialog({
                canSelectFolders: true,
                canSelectFiles: false,
                canSelectMany: false
            });
            // User cancelled
            if (!selectedDirectory) {
                return;
            }
            directory = selectedDirectory[0];
        }
        new RosPackage(directory);
    });
}
exports.registerPackage = registerPackage;
function deregisterPacakge(directory) {
    return __awaiter(this, void 0, void 0, function* () {
        RosPackage.packages.delete(directory.fsPath);
        const config = vscode.workspace.getConfiguration('r-ide');
        config.update('RosPackage.packages', RosPackage.packages);
    });
}
exports.deregisterPacakge = deregisterPacakge;
function loadPackages() {
    return __awaiter(this, void 0, void 0, function* () {
        const config = vscode.workspace.getConfiguration('r-ide');
        let p = config.get('RosPackage.packages');
        if (p) {
            for (let entry of p) {
                RosPackage.packages.set(entry[0], entry[1]);
            }
        }
    });
}
exports.loadPackages = loadPackages;
/**
 * Generates tags to start and end a RIDE auto-generate section
 * @param marker Marks what is being managed between these tags
 * @returns An array of size 2 with the start and end tags
 */
function generateRideTags(marker) {
    return [`# !RIDE START ${marker.toUpperCase()}`, `# !RIDE END ${marker.toUpperCase()}`];
}
/**
 * Updates the RosProject existing packages based on the results of `rospack list-names`
 */
function updateExistingPackages() {
    // This command might be limited to some later ros distros
    //    RosPackage.existingPackages = new Set(cp.execSync(`rospack list-names`).toString().split('\n'));
}
exports.updateExistingPackages = updateExistingPackages;
/**
 * Read a file and identify any possible rospackages
 * @param path The uri path to the file
 * @returns A list of required ROS packages for this file
 */
function readFileForRosPackages(path) {
    return __awaiter(this, void 0, void 0, function* () {
        let otherPackages = new Set();
        yield vscode.workspace.openTextDocument(path).then(document => {
            const text = document.getText();
            // Python
            if (/import/.test(text)) {
                const regex = /import\s+(\w+)|from\s+(\w+(\.\w+)*)\s+import\s+(\w+(,\s*\w+)*)/g;
                let matches = text.matchAll(regex);
                for (let match of matches) {
                    let packageName = match[1] || match[2];
                    if (RosPackage.existingPackages.has(packageName)) {
                        otherPackages.add(packageName);
                    }
                }
                // CPP
            }
            else if (/include/.test(text)) {
                const regex = /#include\s+["<](\S+)[">]/gm;
                let matches = text.matchAll(regex);
                for (let match of matches) {
                    let packageName = match[1];
                    if (RosPackage.existingPackages.has(packageName)) {
                        otherPackages.add(packageName);
                    }
                }
            }
        });
        return otherPackages;
    });
}
function replaceTextInDocument(uri, regexp, replaceText) {
    let start;
    let end;
    vscode.workspace.openTextDocument(uri).then(document => {
        let match = document.getText().match(regexp);
        if (match === null || match === void 0 ? void 0 : match.index) {
            start = document.positionAt(match.index);
            end = document.positionAt(match.index + match[0].length);
            const edit = new vscode.WorkspaceEdit();
            const editRange = new vscode.Range(start, end);
            const makeEdit = new vscode.TextEdit(editRange, replaceText);
            edit.set(uri, [makeEdit]);
            vscode.workspace.applyEdit(edit);
        }
        else {
            throw new Error("Could not find R-IDE tags");
        }
    });
    vscode.window.showInformationMessage(`Updated ${uri.fsPath}`, `Open Document`).then(answer => {
        if (answer === 'Open Document') {
            vscode.window.showTextDocument(uri, { selection: new vscode.Range(start, start.translate({ characterDelta: replaceText.length })) });
        }
    });
}
//# sourceMappingURL=RosPackage.js.map